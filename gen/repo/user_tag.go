// Code generated by meta-egg. DO NOT EDIT.
// WILL BE replace after re-generated!
// DO NOT EDIT.
// Version: v3.8.0
// Author: meta-egg
// Generated at: 2025-08-24 21:54

package repo

import (
	"context"
	"time"

	"meta-egg-layout/gen/model"
	"meta-egg-layout/internal/common/contexts"
	"meta-egg-layout/internal/common/resource"
	"meta-egg-layout/pkg/gormx"

	"gorm.io/gorm"
)

type UserTagRepo interface {
	GetTX(ctx context.Context) *gorm.DB
	Gets(ctx context.Context, opts ...gormx.Option) ([]*model.UserTag, error)
	GetByID(ctx context.Context, id uint64, opts ...gormx.Option) (*model.UserTag, error)
	GetByIDs(ctx context.Context, ids []uint64, opts ...gormx.Option) ([]*model.UserTag, error)
	Create(ctx context.Context, m *model.UserTag) error
	CreateBatch(ctx context.Context, ms []*model.UserTag) error
	Update(ctx context.Context, setCVs map[string]interface{}, incCVs map[string]interface{}, opts ...gormx.Option) (rowsAffected int64, err error)
	UpdateByID(ctx context.Context, id uint64, setCVs map[string]interface{}, incCVs map[string]interface{}) (rowsAffected int64, err error)
	UpdateByIDs(ctx context.Context, ids []uint64, setCVs map[string]interface{}, incCVs map[string]interface{}) (rowsAffected int64, err error)
	Delete(ctx context.Context, opts ...gormx.Option) (rowsAffected int64, err error)
	DeleteByID(ctx context.Context, id uint64) (rowsAffected int64, err error)
	DeleteByIDs(ctx context.Context, ids []uint64) (rowsAffected int64, err error)
	Count(ctx context.Context, opts ...gormx.Option) (count int64, err error)

	// Bind creates a relationship between user and tag
	Bind(ctx context.Context, userId uint64, tagId uint64) error
	// BindBatch creates multiple relationships between user and tag
	BindBatch(ctx context.Context, userIds []uint64, tagIds []uint64) error
	// Unbind removes a specific relationship between user and tag
	Unbind(ctx context.Context, userId uint64, tagId uint64) (rowsAffected int64, err error)
	// UnbindBatchFromUser removes multiple relationships from a specific user
	UnbindBatchFromUser(ctx context.Context, userId uint64, tagIds []uint64) (rowsAffected int64, err error)
	// UnbindBatchFromTag removes multiple relationships from a specific tag
	UnbindBatchFromTag(ctx context.Context, tagId uint64, userIds []uint64) (rowsAffected int64, err error)
	// UnbindAllFromUser removes all relationships from a specific user
	UnbindAllFromUser(ctx context.Context, userId uint64) (rowsAffected int64, err error)
	// UnbindAllFromTag removes all relationships from a specific tag
	UnbindAllFromTag(ctx context.Context, tagId uint64) (rowsAffected int64, err error)
}

type UserTagRepoImpl struct {
	Resource *resource.Resource
}

// get db
func (s *UserTagRepoImpl) GetTX(ctx context.Context) *gorm.DB {
	// in case of transaction
	return s.Resource.DB.GetTX(ctx)
}

func (s *UserTagRepoImpl) Gets(ctx context.Context, opts ...gormx.Option) ([]*model.UserTag, error) {
	var ms []*model.UserTag
	tx := s.GetTX(ctx)
	for _, opt := range opts {
		tx = opt(tx)
	}
	if err := tx.Find(&ms).Error; err != nil {
		return nil, err
	}
	return ms, nil
}

// get by primary key
func (s *UserTagRepoImpl) GetByID(ctx context.Context, id uint64, opts ...gormx.Option) (*model.UserTag, error) { //nolint
	var ms []*model.UserTag
	opts = append(opts, gormx.Where(model.ColUserTagID+" = ?", id), gormx.Limit(1))
	tx := s.GetTX(ctx)
	for _, opt := range opts {
		tx = opt(tx)
	}
	if err := tx.Find(&ms).Error; err != nil {
		return nil, err
	}
	if len(ms) == 0 {
		return nil, gorm.ErrRecordNotFound
	}
	return ms[0], nil
}

// get by primary keys
func (s *UserTagRepoImpl) GetByIDs(ctx context.Context, ids []uint64, opts ...gormx.Option) ([]*model.UserTag, error) {
	if len(ids) == 0 {
		return make([]*model.UserTag, 0), nil
	}
	var ms []*model.UserTag
	opts = append(opts, gormx.Where(model.ColUserTagID+" in (?)", ids))
	ms, err := s.Gets(ctx, opts...)
	if err != nil {
		return nil, err
	}
	return ms, nil
}

// create single record
func (s *UserTagRepoImpl) Create(ctx context.Context, m *model.UserTag) error {
	if me, ok := contexts.GetME(ctx); ok {
		meID := me.ID
		m.CreatedBy = &meID
	}
	return s.GetTX(ctx).Create(m).Error
}

// create batch
func (s *UserTagRepoImpl) CreateBatch(ctx context.Context, ms []*model.UserTag) error {
	if len(ms) == 0 {
		return nil
	}
	if me, ok := contexts.GetME(ctx); ok {
		for _, m := range ms {
			meID := me.ID
			m.CreatedBy = &meID
		}
	}

	return s.GetTX(ctx).CreateInBatches(ms, CreateBatchNum).Error
}

func (s *UserTagRepoImpl) Update(ctx context.Context, setCVs map[string]interface{}, incCVs map[string]interface{}, opts ...gormx.Option) (rowsAffected int64, err error) {
	tx := s.GetTX(ctx).Model(&model.UserTag{})
	for _, opt := range opts {
		tx = opt(tx)
	}
	if setCVs == nil {
		setCVs = make(map[string]interface{})
	}
	for k, v := range incCVs {
		setCVs[k] = gorm.Expr(k+" + ?", v)
	}
	if len(setCVs) == 0 {
		return 0, nil
	}
	result := tx.Updates(setCVs)
	if result.Error != nil {
		err = result.Error
	} else {
		rowsAffected = result.RowsAffected
	}
	return
}

// update by primary key
func (s *UserTagRepoImpl) UpdateByID(ctx context.Context, id uint64, setCVs map[string]interface{}, incCVs map[string]interface{}) (rowsAffected int64, err error) {
	return s.Update(ctx, setCVs, incCVs, gormx.Where(model.ColUserTagID+" = ?", id))
}

// update by primary keys
func (s *UserTagRepoImpl) UpdateByIDs(ctx context.Context, ids []uint64, setCVs map[string]interface{}, incCVs map[string]interface{}) (rowsAffected int64, err error) {
	if len(ids) == 0 {
		return 0, nil
	}
	return s.Update(ctx, setCVs, incCVs, gormx.Where(model.ColUserTagID+" in (?)", ids))
}

// delete
func (s *UserTagRepoImpl) Delete(ctx context.Context, opts ...gormx.Option) (rowsAffected int64, err error) {
	tx := s.GetTX(ctx).Model(&model.UserTag{})
	for _, opt := range opts {
		tx = opt(tx)
	}
	var result *gorm.DB
	if me, ok := contexts.GetME(ctx); ok {
		result = tx.UpdateColumns(map[string]interface{}{
			model.ColUserTagDeletedBy: &(me.ID),
			model.ColUserTagDeletedAt: time.Now().Unix(),
		})
	} else {
		result = tx.Delete(&model.UserTag{})
	}
	if result.Error != nil {
		err = result.Error
	} else {
		rowsAffected = result.RowsAffected
	}
	return
}

// delete by primary key
func (s *UserTagRepoImpl) DeleteByID(ctx context.Context, id uint64) (rowsAffected int64, err error) {
	return s.Delete(ctx, gormx.Where(model.ColUserTagID+" = ?", id))
}

// delete by primary keys
func (s *UserTagRepoImpl) DeleteByIDs(ctx context.Context, ids []uint64) (rowsAffected int64, err error) {
	if len(ids) == 0 {
		return 0, nil
	}
	return s.Delete(ctx, gormx.Where(model.ColUserTagID+" in (?)", ids))
}

// count
func (s *UserTagRepoImpl) Count(ctx context.Context, opts ...gormx.Option) (count int64, err error) {
	tx := s.GetTX(ctx).Model(&model.UserTag{})
	for _, opt := range opts {
		tx = opt(tx)
	}
	result := tx.Count(&count)
	if result.Error != nil {
		err = result.Error
	}
	return
}

// Bind creates a relationship between user and tag
func (s *UserTagRepoImpl) Bind(ctx context.Context, userId uint64, tagId uint64) error {
	m := &model.UserTag{
		UserID: userId,
		TagID:  tagId,
	}
	return s.Create(ctx, m)
}

// BindBatch creates multiple relationships between user and tag
func (s *UserTagRepoImpl) BindBatch(ctx context.Context, userIds []uint64, tagIds []uint64) error {
	if len(userIds) == 0 || len(tagIds) == 0 {
		return nil
	}

	var ms []*model.UserTag
	for _, userId := range userIds {
		for _, tagId := range tagIds {
			ms = append(ms, &model.UserTag{
				UserID: userId,
				TagID:  tagId,
			})
		}
	}
	return s.CreateBatch(ctx, ms)
}

// Unbind removes a specific relationship between user and tag
func (s *UserTagRepoImpl) Unbind(ctx context.Context, userId uint64, tagId uint64) (rowsAffected int64, err error) {
	return s.Delete(ctx,
		gormx.Where(model.ColUserTagUserID+" = ?", userId),
		gormx.Where(model.ColUserTagTagID+" = ?", tagId))
}

// UnbindBatchFromUser removes multiple relationships from a specific user
func (s *UserTagRepoImpl) UnbindBatchFromUser(ctx context.Context, userId uint64, tagIds []uint64) (rowsAffected int64, err error) {
	if len(tagIds) == 0 {
		return 0, nil
	}
	return s.Delete(ctx,
		gormx.Where(model.ColUserTagUserID+" = ?", userId),
		gormx.Where(model.ColUserTagTagID+" in (?)", tagIds))
}

// UnbindBatchFromTag removes multiple relationships from a specific tag
func (s *UserTagRepoImpl) UnbindBatchFromTag(ctx context.Context, tagId uint64, userIds []uint64) (rowsAffected int64, err error) {
	if len(userIds) == 0 {
		return 0, nil
	}
	return s.Delete(ctx,
		gormx.Where(model.ColUserTagTagID+" = ?", tagId),
		gormx.Where(model.ColUserTagUserID+" in (?)", userIds))
}

// UnbindAllFromUser removes all relationships from a specific user
func (s *UserTagRepoImpl) UnbindAllFromUser(ctx context.Context, userId uint64) (rowsAffected int64, err error) {
	return s.Delete(ctx, gormx.Where(model.ColUserTagUserID+" = ?", userId))
}

// UnbindAllFromTag removes all relationships from a specific tag
func (s *UserTagRepoImpl) UnbindAllFromTag(ctx context.Context, tagId uint64) (rowsAffected int64, err error) {
	return s.Delete(ctx, gormx.Where(model.ColUserTagTagID+" = ?", tagId))
}
