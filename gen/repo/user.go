// Code generated by meta-egg. DO NOT EDIT.
// WILL BE replace after re-generated!
// DO NOT EDIT.
// Version: v1.0.0-EE
// Author: meta-egg
// Generated at: 2023-04-16 18:27
package repo

import (
	"context"
	"time"

	"meta-egg-layout/gen/model"
	"meta-egg-layout/gen/repo/option"
	"meta-egg-layout/internal/common/contexts"
	"meta-egg-layout/internal/common/resource"

	"gorm.io/gorm"
)

type UserRepo interface {
	GetDB() *gorm.DB
	Gets(ctx context.Context, opts ...option.Option) ([]*model.User, error)
	GetByID(ctx context.Context, id uint64, opts ...option.Option) (*model.User, error)
	GetByIDs(ctx context.Context, ids []uint64, opts ...option.Option) ([]*model.User, error)
	Create(ctx context.Context, m *model.User) error
	CreateBatch(ctx context.Context, ms []*model.User) error
	Update(ctx context.Context, setCVs map[string]interface{}, opts ...option.Option) (rowsAffected int64, err error)
	UpdateByID(ctx context.Context, id uint64, setCVs map[string]interface{}) (rowsAffected int64, err error)
	UpdateByIDs(ctx context.Context, ids []uint64, setCVs map[string]interface{}) (rowsAffected int64, err error)
	Delete(ctx context.Context, opts ...option.Option) (rowsAffected int64, err error)
	DeleteByID(ctx context.Context, id uint64) (rowsAffected int64, err error)
	DeleteByIDs(ctx context.Context, ids []uint64) (rowsAffected int64, err error)
	Increase(ctx context.Context, incCVs map[string]interface{}, opts ...option.Option) (rowsAffected int64, err error)
	IncreaseByID(ctx context.Context, id uint64, incCVs map[string]interface{}) (rowsAffected int64, err error)
	IncreaseByIDs(ctx context.Context, ids []uint64, incCVs map[string]interface{}) (rowsAffected int64, err error)
	Count(ctx context.Context, opts ...option.Option) (count int64, err error)
}

type UserRepoImpl struct {
	Resource *resource.Resource
}

// get db
func (s *UserRepoImpl) GetDB() *gorm.DB {
	return s.Resource.DB
}

func (s *UserRepoImpl) Gets(ctx context.Context, opts ...option.Option) ([]*model.User, error) {
	var ms []*model.User
	tx := s.Resource.DB
	for _, opt := range opts {
		tx = opt(tx)
	}
	if err := tx.Find(&ms).Error; err != nil {
		return nil, err
	}
	return ms, nil
}

// get by primary key
func (s *UserRepoImpl) GetByID(ctx context.Context, id uint64, opts ...option.Option) (*model.User, error) { //nolint
	var ms []*model.User
	opts = append(opts, option.Where(model.ColUserID+" = ?", id), option.Limit(1))
	ms, err := s.Gets(ctx, opts...)
	if err != nil {
		return nil, err
	}
	if len(ms) == 0 {
		return nil, gorm.ErrRecordNotFound
	}
	return ms[0], nil
}

// get by primary keys
func (s *UserRepoImpl) GetByIDs(ctx context.Context, ids []uint64, opts ...option.Option) ([]*model.User, error) {
	if len(ids) == 0 {
		return make([]*model.User, 0), nil
	}
	var ms []*model.User
	opts = append(opts, option.Where(model.ColUserID+" in (?)", ids))
	ms, err := s.Gets(ctx, opts...)
	if err != nil {
		return nil, err
	}
	return ms, nil
}

// create single record
func (s *UserRepoImpl) Create(ctx context.Context, m *model.User) error {
	if me, ok := contexts.GetME(ctx); ok {
		meID := me.ID
		m.CreatedBy = &meID
		m.UpdatedBy = &meID
	}
	return s.Resource.DB.Create(m).Error
}

// create batch
func (s *UserRepoImpl) CreateBatch(ctx context.Context, ms []*model.User) error {
	if len(ms) == 0 {
		return nil
	}
	if me, ok := contexts.GetME(ctx); ok {
		for _, m := range ms {
			meID := me.ID
			m.CreatedBy = &meID
			m.UpdatedBy = &meID
		}
	}

	return s.Resource.DB.CreateInBatches(ms, CreateBatchNum).Error
}

func (s *UserRepoImpl) Update(ctx context.Context, setCVs map[string]interface{}, opts ...option.Option) (rowsAffected int64, err error) {
	tx := s.Resource.DB.Model(&model.User{})
	for _, opt := range opts {
		tx = opt(tx)
	}
	if me, ok := contexts.GetME(ctx); ok {
		setCVs[model.ColUserUpdatedBy] = me.ID
	}
	result := tx.Updates(setCVs)
	if result.Error != nil {
		err = result.Error
	} else {
		rowsAffected = result.RowsAffected
	}
	return
}

// update by primary key
func (s *UserRepoImpl) UpdateByID(ctx context.Context, id uint64, setCVs map[string]interface{}) (rowsAffected int64, err error) {
	return s.Update(ctx, setCVs, option.Where(model.ColUserID+" = ?", id))
}

// update by primary keys
func (s *UserRepoImpl) UpdateByIDs(ctx context.Context, ids []uint64, setCVs map[string]interface{}) (rowsAffected int64, err error) {
	if len(ids) == 0 {
		return 0, nil
	}
	return s.Update(ctx, setCVs, option.Where(model.ColUserID+" in (?)", ids))
}

func (s *UserRepoImpl) Delete(ctx context.Context, opts ...option.Option) (rowsAffected int64, err error) {
	tx := s.Resource.DB.Model(&model.User{})
	for _, opt := range opts {
		tx = opt(tx)
	}
	var result *gorm.DB
	if me, ok := contexts.GetME(ctx); ok {
		result = tx.UpdateColumns(map[string]interface{}{
			model.ColUserDeletedBy: &(me.ID),
			model.ColUserDeletedAt: time.Now(),
		})
	} else {
		result = tx.Delete(&model.User{})
	}
	if result.Error != nil {
		err = result.Error
	} else {
		rowsAffected = result.RowsAffected
	}
	return
}

// delete by primary key
func (s *UserRepoImpl) DeleteByID(ctx context.Context, id uint64) (rowsAffected int64, err error) {
	return s.Delete(ctx, option.Where(model.ColUserID+" = ?", id))
}

// delete by primary keys
func (s *UserRepoImpl) DeleteByIDs(ctx context.Context, ids []uint64) (rowsAffected int64, err error) {
	if len(ids) == 0 {
		return 0, nil
	}
	return s.Delete(ctx, option.Where(model.ColUserID+" in (?)", ids))
}

func (s *UserRepoImpl) Increase(ctx context.Context, incCVs map[string]interface{}, opts ...option.Option) (rowsAffected int64, err error) {
	if len(incCVs) == 0 {
		return 0, nil
	}
	tx := s.Resource.DB.Model(&model.User{})
	for _, opt := range opts {
		tx = opt(tx)
	}
	setCVs := make(map[string]interface{})
	for k, v := range incCVs {
		setCVs[k] = gorm.Expr(k+" + ?", v)
	}
	if me, ok := contexts.GetME(ctx); ok {
		setCVs[model.ColUserUpdatedBy] = me.ID
	}
	result := tx.Updates(setCVs)
	if result.Error != nil {
		err = result.Error
	} else {
		rowsAffected = result.RowsAffected
	}
	return
}

// increase by primary key
func (s *UserRepoImpl) IncreaseByID(ctx context.Context, id uint64, incCVs map[string]interface{}) (rowsAffected int64, err error) {
	return s.Increase(ctx, incCVs, option.Where(model.ColUserID+" = ?", id))
}

// increase by primary keys
func (s *UserRepoImpl) IncreaseByIDs(ctx context.Context, ids []uint64, incCVs map[string]interface{}) (rowsAffected int64, err error) {
	if len(ids) == 0 {
		return 0, nil
	}
	return s.Increase(ctx, incCVs, option.Where(model.ColUserID+" in (?)", ids))
}

// count
func (s *UserRepoImpl) Count(ctx context.Context, opts ...option.Option) (count int64, err error) {
	tx := s.Resource.DB.Model(&model.User{})
	for _, opt := range opts {
		tx = opt(tx)
	}
	result := tx.Count(&count)
	if result.Error != nil {
		err = result.Error
	}
	return
}
