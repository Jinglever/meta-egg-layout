// Code generated by meta-egg. DO NOT EDIT.
// WILL BE replace after re-generated!
// DO NOT EDIT.
// Version: v3.8.0
// Author: meta-egg
// Generated at: 2025-08-24 21:54

package repo

import (
	"context"

	"meta-egg-layout/gen/model"
	"meta-egg-layout/internal/common/resource"
	"meta-egg-layout/pkg/gormx"

	"gorm.io/gorm"
)

type TagRepo interface {
	GetTX(ctx context.Context) *gorm.DB
	Gets(ctx context.Context, opts ...gormx.Option) ([]*model.Tag, error)
	GetByID(ctx context.Context, id uint64, opts ...gormx.Option) (*model.Tag, error)
	GetByIDs(ctx context.Context, ids []uint64, opts ...gormx.Option) ([]*model.Tag, error)
	Create(ctx context.Context, m *model.Tag) error
	CreateBatch(ctx context.Context, ms []*model.Tag) error
	Update(ctx context.Context, setCVs map[string]interface{}, incCVs map[string]interface{}, opts ...gormx.Option) (rowsAffected int64, err error)
	UpdateByID(ctx context.Context, id uint64, setCVs map[string]interface{}, incCVs map[string]interface{}) (rowsAffected int64, err error)
	UpdateByIDs(ctx context.Context, ids []uint64, setCVs map[string]interface{}, incCVs map[string]interface{}) (rowsAffected int64, err error)
	Delete(ctx context.Context, opts ...gormx.Option) (rowsAffected int64, err error)
	DeleteByID(ctx context.Context, id uint64) (rowsAffected int64, err error)
	DeleteByIDs(ctx context.Context, ids []uint64) (rowsAffected int64, err error)
	Count(ctx context.Context, opts ...gormx.Option) (count int64, err error)
}

type TagRepoImpl struct {
	Resource *resource.Resource
}

// get db
func (s *TagRepoImpl) GetTX(ctx context.Context) *gorm.DB {
	// in case of transaction
	return s.Resource.DB.GetTX(ctx)
}

func (s *TagRepoImpl) Gets(ctx context.Context, opts ...gormx.Option) ([]*model.Tag, error) {
	var ms []*model.Tag
	tx := s.GetTX(ctx)
	for _, opt := range opts {
		tx = opt(tx)
	}
	if err := tx.Find(&ms).Error; err != nil {
		return nil, err
	}
	return ms, nil
}

// get by primary key
func (s *TagRepoImpl) GetByID(ctx context.Context, id uint64, opts ...gormx.Option) (*model.Tag, error) { //nolint
	var ms []*model.Tag
	opts = append(opts, gormx.Where(model.ColTagID+" = ?", id), gormx.Limit(1))
	tx := s.GetTX(ctx)
	for _, opt := range opts {
		tx = opt(tx)
	}
	if err := tx.Find(&ms).Error; err != nil {
		return nil, err
	}
	if len(ms) == 0 {
		return nil, gorm.ErrRecordNotFound
	}
	return ms[0], nil
}

// get by primary keys
func (s *TagRepoImpl) GetByIDs(ctx context.Context, ids []uint64, opts ...gormx.Option) ([]*model.Tag, error) {
	if len(ids) == 0 {
		return make([]*model.Tag, 0), nil
	}
	var ms []*model.Tag
	opts = append(opts, gormx.Where(model.ColTagID+" in (?)", ids))
	ms, err := s.Gets(ctx, opts...)
	if err != nil {
		return nil, err
	}
	return ms, nil
}

// create single record
func (s *TagRepoImpl) Create(ctx context.Context, m *model.Tag) error {
	return s.GetTX(ctx).Create(m).Error
}

// create batch
func (s *TagRepoImpl) CreateBatch(ctx context.Context, ms []*model.Tag) error {
	if len(ms) == 0 {
		return nil
	}

	return s.GetTX(ctx).CreateInBatches(ms, CreateBatchNum).Error
}

func (s *TagRepoImpl) Update(ctx context.Context, setCVs map[string]interface{}, incCVs map[string]interface{}, opts ...gormx.Option) (rowsAffected int64, err error) {
	tx := s.GetTX(ctx).Model(&model.Tag{})
	for _, opt := range opts {
		tx = opt(tx)
	}
	if setCVs == nil {
		setCVs = make(map[string]interface{})
	}
	for k, v := range incCVs {
		setCVs[k] = gorm.Expr(k+" + ?", v)
	}
	if len(setCVs) == 0 {
		return 0, nil
	}
	result := tx.Updates(setCVs)
	if result.Error != nil {
		err = result.Error
	} else {
		rowsAffected = result.RowsAffected
	}
	return
}

// update by primary key
func (s *TagRepoImpl) UpdateByID(ctx context.Context, id uint64, setCVs map[string]interface{}, incCVs map[string]interface{}) (rowsAffected int64, err error) {
	return s.Update(ctx, setCVs, incCVs, gormx.Where(model.ColTagID+" = ?", id))
}

// update by primary keys
func (s *TagRepoImpl) UpdateByIDs(ctx context.Context, ids []uint64, setCVs map[string]interface{}, incCVs map[string]interface{}) (rowsAffected int64, err error) {
	if len(ids) == 0 {
		return 0, nil
	}
	return s.Update(ctx, setCVs, incCVs, gormx.Where(model.ColTagID+" in (?)", ids))
}

func (s *TagRepoImpl) Delete(ctx context.Context, opts ...gormx.Option) (rowsAffected int64, err error) {
	tx := s.GetTX(ctx).Model(&model.Tag{})
	for _, opt := range opts {
		tx = opt(tx)
	}
	result := tx.Delete(&model.Tag{})
	if result.Error != nil {
		err = result.Error
	} else {
		rowsAffected = result.RowsAffected
	}
	return
}

// delete by primary key
func (s *TagRepoImpl) DeleteByID(ctx context.Context, id uint64) (rowsAffected int64, err error) {
	return s.Delete(ctx, gormx.Where(model.ColTagID+" = ?", id))
}

// delete by primary keys
func (s *TagRepoImpl) DeleteByIDs(ctx context.Context, ids []uint64) (rowsAffected int64, err error) {
	if len(ids) == 0 {
		return 0, nil
	}
	return s.Delete(ctx, gormx.Where(model.ColTagID+" in (?)", ids))
}

// count
func (s *TagRepoImpl) Count(ctx context.Context, opts ...gormx.Option) (count int64, err error) {
	tx := s.GetTX(ctx).Model(&model.Tag{})
	for _, opt := range opts {
		tx = opt(tx)
	}
	result := tx.Count(&count)
	if result.Error != nil {
		err = result.Error
	}
	return
}
